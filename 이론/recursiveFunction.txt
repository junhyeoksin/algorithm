재귀함수

- 재귀함수는 정의 단계에서 자신을 재참조하는 함수
- 전달되는 상태인 매개변수가 달라질 뿐 똑같은 일을 하는 함수
- 큰 문제를 작은 부분 문제로 나눠서 풀때 사용

* Factorial of a Number
n! = n * (n-1) * (n-2) * .... * 1

주의사항 : 반드시 기저사례를 써야한다. 사이클이 있다면 쓰면 안된다. 반복문으로 가능하다면 반복문사용이 좋다.
이유 :
    1. 기저사례 사용
    ex) if( n == 1 || n == 0) return 1;
    - 기저사례는 맨앞에 두어야한다. 가저사례는 재귀함수를 종료시킨다. 상단에 배치하면 함수가 더 복잡한 논리(메인로직) 로 진행해야하는지 재귀 호출로 진행해야하는지 빠르게 판단하고 종료시킬 수 있다.
    이를 통해 효율적인 코드가 될 수 있다.
    - 무한 재귀방지를 한다. 메인로직이 재귀보다 앞에 있다면 메인로직이 실행되기 때문이다.
    - 재귀함수는 보통 어떤 문제를 쪼개어서 더 작은 사례에 대한 해결책으로 푸는 방법중 하나로 사용한다. 이 때문에 재귀함수의 매개변수 자체가 계속 작게 되다가 결국 1 또는 문제에서 주어진 작은 최솟값이 된다.
    이때 종료를 시켜야 되기 때문에 해당 매개변수가 작아지다가 종료 해야 하기 때문에 맨앞에 있어야 한다.
    또한 계속해서 매개변수를 증가시키는 경우도 마찬가지이다.


- 순열과 조합

1. 순열
permutation 이란 순서가 정해진 임의의 집합을 다른 순서로 섞는 연산을 말한다.
n 개의 집합 중 n개를 고르는 순열의 개수를 n! 이라는 특징을 가지고 있다.

next_permutation()의 원리
새로운 순열이 이전 순열보다 사전순으로 큰 경우 true 반환한다. 마지막 순열에 도달하고 범위가 첫 번쨰 순열로 재설정된 경우 false 반환

- vector 로 구현한 순열
#include <bits/stdc++.h>
using namespace std;
void printV(vector<int> &v){
     for(int i = 0; i < v.size(); i++){
        cout << v[i] << " ";
     }
     cout << "\n";
}
int main(){
    int a[3] = {1,2,3};
    vector<int> v;
    for(int i = 0; i < 3; i ++ ) v.push_back(a[i]);
    do{
        printV(v);
    }while(next_permutation(v.begin(), v.end());
}

-  Array 사용한 순열   : 정적배열 Array를 사용했기 때문에 vector와 같은 begin(), end()를 쓸 수 없다,
int main(){
  int b[] = {1,2,3};
  do{
      for(int i : b) cout << i << " ";
      cout << '\n';
  }while(next_permutation(b, b + 3));  // 열의 끝 다음의 주소인 b  + 3
  // while(next_permutation(&a[0], &a[3])) // 해당 주서값을 가리켜서 지정할 수도  있다.

}